// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Sat Dec 06 15:06:44 CET 2003
//only include this file for midp1-devices:
//#condition polish.midp1 && polish.usePolishGui
/*
 * Copyright (c) 2004 Robert Virkus / Enough Software
 *
 * This file is part of J2ME Polish.
 *
 * J2ME Polish is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * J2ME Polish is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Foobar; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 * Commercial licenses are also available, please
 * refer to the accompanying LICENSE.txt or visit
 * http://www.j2mepolish.org for details.
 */
package de.enough.polish.ui.game;


import javax.microedition.lcdui.Graphics;
import javax.microedition.lcdui.Image;

//#ifdef polish.api.nokia-ui
	import com.nokia.mid.ui.DirectGraphics;
	import com.nokia.mid.ui.DirectUtils;
//#endif

/**
 * A Sprite is a basic visual element that can be rendered with one of
 * several frames stored in an Image; different frames can be shown to
 * animate the Sprite.  Several transforms such as flipping and rotation
 * can also be applied to a Sprite to further vary its appearance.  As with
 * all Layer subclasses, a Sprite's location can be changed and it can also
 * be made visible or invisible.
 * <h3>Sprite Frames</h3>
 * The raw frames used to render a Sprite are provided in a single Image
 * object, which may be mutable or immutable.  If more than one frame is used,
 * the Image is broken up into a series of equally-sized frames of a specified
 * width and height.  As shown in the figure below, the same set of frames may
 * be stored in several different arrangements depending on what is the most
 * convenient for the game developer.
 * <br>
 * <center><img src="doc-files/frames.gif" width=777 height=402
 * ALT="Sprite Frames"></center>
 * <br>
 * <p>
 * Each frame is assigned a unique index number.  The frame located in the
 * upper-left corner of the Image is assigned an index of 0.  The remaining
 * frames are then numbered consecutively in row-major order (indices are
 * assigned across the first row, then the second row, and so on).  The method
 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#getRawFrameCount()"><CODE>getRawFrameCount()</CODE></A> returns the total number of raw frames.
 * <h3>Frame Sequence</h3>
 * A Sprite's frame sequence defines an ordered list of frames to be displayed.
 * The default frame sequence mirrors the list of available frames, so
 * there is a direct mapping between the sequence index and the corresponding
 * frame index.  This also means that the length of the default frame sequence
 * is equal to the number of raw frames.  For example, if a Sprite has 4
 * frames, its default frame sequence is {0, 1, 2, 3}.
 * <center><img src="doc-files/defaultSequence.gif" width=182 height=269
 * ALT="Default Frame Sequence"></center>
 * The developer must manually switch the current frame in the frame sequence.
 * This may be accomplished by calling <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#setFrame(int)"><CODE>setFrame(int)</CODE></A>,
 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#prevFrame()"><CODE>prevFrame()</CODE></A>, or <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#nextFrame()"><CODE>nextFrame()</CODE></A>.  Note that these methods
 * always operate on the sequence index, they do not operate on frame indices;
 * however, if the default frame sequence is used, then the sequence indices
 * and the frame indices are interchangeable.
 * If desired, an arbitrary frame sequence may be defined for a Sprite.
 * The frame sequence must contain at least one element, and each element must
 * reference a valid frame index.  By defining a new frame sequence, the
 * developer can conveniently display the Sprite's frames in any order
 * desired; frames may be repeated, omitted, shown in reverse order, etc.
 * For example, the diagram below shows how a special frame sequence might be
 * used to animate a mosquito.  The frame sequence is designed so that the
 * mosquito flaps its wings three times and then pauses for a moment before
 * the cycle is repeated.
 * <center><img src="doc-files/specialSequence.gif" width=346 height=510
 * ALT="Special Frame Sequence"></center>
 * By calling <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#nextFrame()"><CODE>nextFrame()</CODE></A> each time the display is updated, the
 * resulting animation would like this:
 * <br>
 * <center><img src="doc-files/sequenceDemo.gif" width=96 height=36></center>
 * <h3>Reference Pixel</h3>
 * Being a subclass of Layer, Sprite inherits various methods for setting and
 * retrieving its location such as <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#setPosition(int, int)"><CODE>setPosition(x,y)</CODE></A>,
 * <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getX()"><CODE>getX()</CODE></A>, and <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getY()"><CODE>getY()</CODE></A>.  These methods all define
 * position in terms of the upper-left corner of the Sprite's visual bounds;
 * however, in some cases, it is more convenient to define the Sprite's position
 * in terms of an arbitrary pixel within its frame, especially if transforms
 * are applied to the Sprite.
 * Therefore, Sprite includes the concept of a <em>reference pixel</em>.
 * The reference pixel is defined by specifying its location in the
 * Sprite's untransformed frame using
 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#defineReferencePixel(int, int)"><CODE>defineReferencePixel(x,y)</CODE></A>.
 * By default, the reference pixel is defined to be the pixel at (0,0)
 * in the frame.  If desired, the reference pixel may be defined outside
 * of the frame's bounds.
 * <p>
 * In this example, the reference pixel is defined to be the pixel that
 * the monkey appears to be hanging from:
 * <p>
 * <center><img src="doc-files/refpixel.gif" width=304 height=199
 * ALT="Defining The Reference Pixel"></center>
 * <p>
 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#getRefPixelX()"><CODE>getRefPixelX()</CODE></A> and <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#getRefPixelY()"><CODE>getRefPixelY()</CODE></A>
 * can be used to query the location of the reference pixel in the painter's
 * coordinate system.  The developer can also use
 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#setRefPixelPosition(int, int)"><CODE>setRefPixelPosition(x,y)</CODE></A> to position the Sprite
 * so that reference pixel appears at a specific location in the painter's
 * coordinate system.  These methods automatically account for any transforms
 * applied to the Sprite.
 * <p>
 * In this example, the reference pixel's position is set to a point at the end
 * of a tree branch; the Sprite's location changes so that the reference pixel
 * appears at this point and the monkey appears to be hanging from the branch:
 * <p>
 * <center><img src="doc-files/setrefposition.gif" width=332 height=350
 * ALT="Setting The Reference Pixel Position"></center>
 * <p>
 * <a name="transforms"></a>
 * <h3>Sprite Transforms</h3>
 * Various transforms can be applied to a Sprite.  The available transforms
 * include rotations in multiples of 90 degrees, and mirrored (about
 * the vertical axis) versions of each of the rotations.  A Sprite's transform
 * is set by calling <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#setTransform(int)"><CODE>setTransform(transform)</CODE></A>.
 * <p>
 * <center><img src="doc-files/transforms.gif" width=355 height=575
 * ALT="Transforms"></center>
 * <br>
 * When a transform is applied, the Sprite is automatically repositioned
 * such that the  reference pixel appears stationary in the painter's
 * coordinate system.  Thus, the reference pixel effectively becomes the
 * center of the transform operation.  Since the reference pixel does not
 * move, the values returned by <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#getRefPixelX()"><CODE>getRefPixelX()</CODE></A> and
 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#getRefPixelY()"><CODE>getRefPixelY()</CODE></A> remain the same; however, the values returned by
 * <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getX()"><CODE>getX()</CODE></A> and <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getY()"><CODE>getY()</CODE></A> may change to reflect the
 * movement of the Sprite's upper-left corner.
 * <p>
 * Referring to the monkey example once again, the position of the
 * reference pixel remains at (48, 22) when a 90 degree rotation
 * is applied, thereby making it appear as if the monkey is swinging
 * from the branch:
 * <p>
 * <center><img src="doc-files/transcenter.gif" width=333 height=350
 * ALT="Transform Center"></center>
 * <p>
 * <h3>Sprite Drawing</h3>
 * Sprites can be drawn at any time using the <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#paint(javax.microedition.lcdui.Graphics)"><CODE>paint(Graphics)</CODE></A> method.
 * The Sprite will be drawn on the Graphics object according to the current
 * state information maintained by the Sprite (i.e. position, frame,
 * visibility).  Erasing the Sprite is always the responsibility of code
 * outside the Sprite class.<p>
 * <p>
 * Sprites can be implemented using whatever techniques a manufacturers
 * wishes to use (e.g hardware acceleration may be used for all Sprites, for
 * certain sizes of Sprites, or not at all).
 * <p>
 * For some platforms, certain Sprite sizes may be more efficient than others;
 * manufacturers may choose to provide developers with information about
 * device-specific characteristics such as these.
 * <p>
 * <HR>
 * 
 * 
 * @since MIDP 2.0
 */
public class Sprite extends Layer
{
	/**
	 * No transform is applied to the Sprite.
	 * This constant has a value of <code>0</code>.</DL>
	 * 
	 */
	public static final int TRANS_NONE = 0;

	/**
	 * Causes the Sprite to appear rotated clockwise by 90 degrees.
	 * This constant has a value of <code>5</code>.</DL>
	 * 
	 */
	public static final int TRANS_ROT90 = 5;

	/**
	 * Causes the Sprite to appear rotated clockwise by 180 degrees.
	 * This constant has a value of <code>3</code>.</DL>
	 * 
	 */
	public static final int TRANS_ROT180 = 3;

	/**
	 * Causes the Sprite to appear rotated clockwise by 270 degrees.
	 * This constant has a value of <code>6</code>.</DL>
	 * 
	 */
	public static final int TRANS_ROT270 = 6;

	/**
	 * Causes the Sprite to appear reflected about its vertical
	 * center.
	 * This constant has a value of <code>2</code>.</DL>
	 * 
	 */
	public static final int TRANS_MIRROR = 2;

	/**
	 * Causes the Sprite to appear reflected about its vertical
	 * center and then rotated clockwise by 90 degrees.
	 * This constant has a value of <code>7</code>.</DL>
	 * 
	 */
	public static final int TRANS_MIRROR_ROT90 = 7;

	/**
	 * Causes the Sprite to appear reflected about its vertical
	 * center and then rotated clockwise by 180 degrees.
	 * This constant has a value of <code>1</code>.</DL>
	 * 
	 */
	public static final int TRANS_MIRROR_ROT180 = 1;

	/**
	 * Causes the Sprite to appear reflected about its vertical
	 * center and then rotated clockwise by 270 degrees.
	 * This constant has a value of <code>4</code>.</DL>
	 * 
	 * 
	 */
	public static final int TRANS_MIRROR_ROT270 = 4;
		
	private Image image;
	private int refPixelX;
	private int refPixelY;
	private int frameSequenceIndex;
	private int[] frameSequence;
	private int transform;
	//#ifdef polish.api.nokia-ui
		private int nokiaTransform;
		private Image nokiaFrame;
		private Image[] nokiaFrames;
	//#endif
	private int collisionX;
	private int collisionY;
	private int collisionWidth;
	private int collisionHeight;
	private int transformedCollisionX;
	private int transformedCollisionY;
	private int transformedCollisionWidth;
	private int transformedCollisionHeight;

	private int frameHeight;
	private int frameWidth;
	private int rawFrameCount;
	private int transformedRefX;
	private int transformedRefY;
	private int numberOfColumns;
	private int column;
	private int row;

	/**
	 * Creates a new non-animated Sprite using the provided Image.
	 * This constructor is functionally equivalent to calling
	 * <code>new Sprite(image, image.getWidth(), image.getHeight())</code>
	 * <p>
	 * By default, the Sprite is visible and its upper-left
	 * corner is positioned at (0,0) in the painter's coordinate system.
	 * <br>
	 * 
	 * @param image the Image to use as the single frame for the Sprite
	 * @throws NullPointerException if img is null
	 */
	public Sprite( Image image)
	{
		setImage( image, image.getWidth(), image.getHeight() );
	}

	/**
	 * Creates a new animated Sprite using frames contained in
	 * the provided Image.  The frames must be equally sized, with the
	 * dimensions specified by <code>frameWidth</code> and
	 * <code>frameHeight</code>.  They may be laid out in the image
	 * horizontally, vertically, or as a grid.  The width of the source
	 * image must be an integer multiple of the frame width, and the height
	 * of the source image must be an integer multiple of the frame height.
	 * The  values returned by <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getWidth()"><CODE>Layer.getWidth()</CODE></A> and
	 * <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getHeight()"><CODE>Layer.getHeight()</CODE></A> will reflect the frame width and frame height
	 * subject to the Sprite's current transform.
	 * <p>
	 * Sprites have a default frame sequence corresponding to the raw frame
	 * numbers, starting with frame 0.  The frame sequence may be modified
	 * with <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#setFrameSequence(int[])"><CODE>setFrameSequence(int[])</CODE></A>.
	 * <p>
	 * By default, the Sprite is visible and its upper-left corner is
	 * positioned at (0,0) in the painter's coordinate system.
	 * <p>
	 * 
	 * @param image the Image to use for Sprite
	 * @param frameWidth the width, in pixels, of the individual raw frames
	 * @param frameHeight the height, in pixels, of the individual raw frames
	 * @throws NullPointerException if img is null
	 * @throws IllegalArgumentException if frameHeight or frameWidth is less than 1
	 *									or if the image width is not an integer multiple of the frameWidth
	 *									or if the image height is not an integer multiple of the frameHeight
	 */
	public Sprite( Image image, int frameWidth, int frameHeight)
	{
		setImage(image, frameWidth, frameHeight);
	}

	/**
	 * Creates a new Sprite from another Sprite. 
	 * 
	 * All instance attributes (raw frames, position, frame sequence, current
	 * frame, reference point, collision rectangle, transform, and visibility)
	 * of the source Sprite are duplicated in the new Sprite.
	 * 
	 * @param s  the Sprite to create a copy of
	 * @throws NullPointerException if s is null
	 */
	public Sprite( Sprite s)
	{
		this.image = s.image;
		this.frameWidth = s.frameWidth;
		this.frameHeight = s.frameHeight;
		this.width = s.width;
		this.height = s.height;
		this.xPosition = s.xPosition;
		this.yPosition = s.yPosition;
		this.frameSequenceIndex = s.frameSequenceIndex;
		this.frameSequence = s.frameSequence;
		this.refPixelX = s.refPixelX;
		this.refPixelY = s.refPixelY;
		this.transformedRefX = s.transformedRefX;
		this.transformedRefY = s.transformedRefY;
		this.transform = s.transform;
		//#ifdef polish.api.nokia-ui
			this.nokiaTransform = s.nokiaTransform;
		//#endif
		this.collisionX = s.collisionX;
		this.collisionY = s.collisionY;
		this.collisionWidth = s.collisionWidth;
		this.collisionHeight = s.collisionHeight;
		this.transformedCollisionX = s.transformedCollisionX;
		this.transformedCollisionY = s.transformedCollisionY;
		this.transformedCollisionWidth = s.transformedCollisionWidth;
		this.transformedCollisionHeight = s.transformedCollisionHeight;
	}

	/**
	 * Defines the reference pixel for this Sprite.  The pixel is
	 * defined by its location relative to the upper-left corner of
	 * the Sprite's un-transformed frame, and it may lay outside of
	 * the frame's bounds.
	 * <p>
	 * When a transformation is applied, the reference pixel is
	 * defined relative to the Sprite's initial upper-left corner
	 * before transformation. This corner may no longer appear as the
	 * upper-left corner in the painter's coordinate system under
	 * current transformation.
	 * <p>
	 * By default, a Sprite's reference pixel is located at (0,0); that is,
	 * the pixel in the upper-left corner of the raw frame.
	 * <p>
	 * Changing the reference pixel does not change the
	 * Sprite's physical position in the painter's coordinate system;
	 * that is, the values returned by <A HREF="../../../../de/enough/polish/ui/game/Layer.html#getX()"><CODE>getX()</CODE></A> and
	 * <A HREF="../../../../de/enough/polish/ui/game/Layer.html#getY()"><CODE>getY()</CODE></A> will not change as a result of defining the
	 * reference pixel.  However, subsequent calls to methods that
	 * involve the reference pixel will be impacted by its new definition.
	 * 
	 * @param refX the horizontal location of the reference pixel, relative to the left edge of the un-transformed frame
	 * @param refY the vertical location of the reference pixel, relative to the top edge of the un-transformed frame
	 * @see #setRefPixelPosition(int, int), #getRefPixelX(), #getRefPixelY()
	 */
	public void defineReferencePixel(int refX, int refY)
	{
		this.refPixelX = refX;
		this.refPixelY = refY;
		this.transformedRefX = refX;
		this.transformedRefY = refY;
	}

	/**
	 * Sets this Sprite's position such that its reference pixel is located
	 * at (x,y) in the painter's coordinate system.
	 * 
	 * @param x the horizontal location at which to place the reference pixel
	 * @param y the vertical location at which to place the reference pixel
	 * @see #defineReferencePixel(int, int),  #getRefPixelX(), #getRefPixelY()
	 */
	public void setRefPixelPosition(int x, int y)
	{
		this.xPosition = x - this.transformedRefX;
		this.yPosition = y - this.transformedRefY;
	}

	/**
	 * Gets the horizontal position of this Sprite's reference pixel
	 * in the painter's coordinate system.
	 * 
	 * @return the horizontal location of the reference pixel
	 * @see #defineReferencePixel(int, int),  #setRefPixelPosition(int, int), #getRefPixelY()
	 */
	public int getRefPixelX()
	{
		return this.refPixelX;
	}

	/**
	 * Gets the vertical position of this Sprite's reference pixel
	 * in the painter's coordinate system.
	 * 
	 * @return the vertical location of the reference pixel
	 * @see #defineReferencePixel(int, int),  #setRefPixelPosition(int, int), #getRefPixelX()
	 */
	public int getRefPixelY()
	{
		return this.refPixelY;
	}

	/**
	 * Selects the current frame in the frame sequence.  
	 * <p>
	 * The current frame is rendered when 
	 * <A HREF="../../../../de/enough/polish/ui/game/Sprite.html#paint(javax.microedition.lcdui.Graphics)"><CODE>paint(Graphics)</CODE></A>
	 * is called.
	 * <p>
	 * The index provided refers to the desired entry in the frame sequence,
	 * not the index of the actual frame itself.
	 * 
	 * @param sequenceIndex the index of of the desired entry in the frame  sequence
	 * @throws IndexOutOfBoundsException if frameIndex is less than 0
	 *									 or if frameIndex is equal to or greater than the length of the current frame sequence (or the number of raw frames for the default sequence)
	 * @see #setFrameSequence(int[]), getFrame()
	 */
	public void setFrame(int sequenceIndex)
	{
		this.frameSequenceIndex = sequenceIndex;
	}

	/**
	 * Gets the current index in the frame sequence.
	 * The index returned refers to the current entry in the frame sequence,
	 * not the index of the actual frame that is displayed.
	 * 
	 * @return the current index in the frame sequence
	 * @see #setFrameSequence(int[]),  #setFrame(int)
	 */
	public final int getFrame()
	{
		return this.frameSequenceIndex;
	}

	/**
	 * Gets the number of raw frames for this Sprite.  The value returned
	 * reflects the number of frames; it does not reflect the length of the
	 * Sprite's frame sequence.  However, these two values will be the same
	 * if the default frame sequence is used.
	 * 
	 * @return the number of raw frames for this Sprite
	 * @see #getFrameSequenceLength()
	 */
	public int getRawFrameCount()
	{
		return this.rawFrameCount;
	}

	/**
	 * Gets the number of elements in the frame sequence.  The value returned
	 * reflects the length of the Sprite's frame sequence; it does not reflect
	 * the number of raw frames.  However, these two values will be the same
	 * if the default frame sequence is used.
	 * 
	 * @return the number of elements in this Sprite's frame sequence
	 * @see #getRawFrameCount()
	 */
	public int getFrameSequenceLength()
	{
		return this.frameSequence.length;
	}

	/**
	 * Selects the next frame in the frame sequence.  <p>
	 * 
	 * The frame sequence is considered to be circular, i.e. if
	 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#nextFrame()"><CODE>nextFrame()</CODE></A> is called when at the end of the sequence,
	 * this method will advance to the first entry in the sequence.
	 * 
	 * @see #setFrameSequence(int[]),  #prevFrame()
	 */
	public void nextFrame()
	{
		this.frameSequenceIndex++;
		if (this.frameSequenceIndex >= this.frameSequence.length ) {
			this.frameSequenceIndex = 0;
		}
		updateFrame();
	}

	/**
	 * Selects the previous frame in the frame sequence.  <p>
	 * 
	 * The frame sequence is considered to be circular, i.e. if
	 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#prevFrame()"><CODE>prevFrame()</CODE></A> is called when at the start of the sequence,
	 * this method will advance to the last entry in the sequence.
	 * 
	 * @see #setFrameSequence(int[]),  #nextFrame()
	 */
	public void prevFrame()
	{
		this.frameSequenceIndex--;
		if (this.frameSequenceIndex < 0 ) {
			this.frameSequenceIndex = this.frameSequence.length - 1;
		}
		updateFrame();
	}

	/**
	 * Updates the position at which the image should be drawn,
	 * This depends on the frame-index as well as the current transformation.
	 */
	private void updateFrame() {
		if (this.frameSequence == null) {
			return;
		}
		int frameIndex = this.frameSequence[ this.frameSequenceIndex ];
		int c = frameIndex % this.numberOfColumns;
		int r = frameIndex / this.numberOfColumns;
		
		//#ifdef polish.api.nokia-ui
			Image frame = this.nokiaFrames[ frameIndex ];
			if ( frame == null ) {
				frame = DirectUtils.createImage( this.frameWidth, this.frameHeight, 0x00FFFFFF );
				Graphics g = frame.getGraphics();
				// when creating an transparent image, one must not "touch"
				// that image with an ordinary Graphics-object --- instead
				// ALWAYS an DirectGraphics-object needs to be used. Sigh!
				//g.drawImage(this.image, -(c * this.frameWidth), -(r * this.frameHeight), Graphics.TOP | Graphics.LEFT );
				DirectGraphics dg = DirectUtils.getDirectGraphics(g);
				dg.drawImage(this.image, -(c * this.frameWidth), -(r * this.frameHeight), Graphics.TOP | Graphics.LEFT, 0 );
			}
			this.nokiaFrame = frame; 
		//#else
			int numberOfRows = this.rawFrameCount / this.numberOfColumns;
			
			this.column = c;
			this.row = r;
			switch (this.transform ) {
				case TRANS_NONE:
					this.column = c;
					this.row = r;
					break;
				case TRANS_MIRROR_ROT180:
					this.column = c;
					this.row = (numberOfRows-1) - r;
					break;
				case TRANS_MIRROR:
					this.column = (this.numberOfColumns -1) - c;
					this.row = r;
					break;
				case TRANS_ROT180:
					this.column = (this.numberOfColumns -1) - c;
					this.row = (numberOfRows-1) - r;
					break;
				case TRANS_MIRROR_ROT270:
					this.column = c;
					this.row = r;
					break;
				case TRANS_ROT90:
					this.column = (numberOfRows -1) - r;
					this.row = c;
					break;
				case TRANS_ROT270:
					this.column = r;
					this.row = (this.numberOfColumns -1) - c;
					break;
				case TRANS_MIRROR_ROT90:
					this.row = (numberOfRows-1) - r;
					this.row = (this.numberOfColumns -1) - c;
					break;
			}
		//#endif
	}

	/**
	 * Draws the Sprite.
	 * <P>
	 * Draws current frame of Sprite using the provided Graphics object.
	 * The Sprite's upper left corner is rendered at the Sprite's current
	 * position relative to the origin of the Graphics object.  The current
	 * position of the Sprite's upper-left corner can be retrieved by
	 * calling <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getX()"><CODE>Layer.getX()</CODE></A> and <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getY()"><CODE>Layer.getY()</CODE></A>.
	 * <P>
	 * Rendering is subject to the clip region of the Graphics object.
	 * The Sprite will be drawn only if it is visible.
	 * <p>
	 * If the Sprite's Image is mutable, the Sprite is rendered using the
	 * current contents of the Image.
	 * 
	 * @param g the graphics object to draw Sprite on
	 * @throws NullPointerException - if g is null
	 * @see Layer#paint(Graphics) in class Layer
	 */
	public final void paint( Graphics g)
	{
		//#ifdef polish.api.nokia-ui
			// just draw and rotate the current frame:
			DirectGraphics dg = DirectUtils.getDirectGraphics( g );
			dg.drawImage(this.nokiaFrame, this.xPosition, this.yPosition, Graphics.TOP | Graphics.LEFT, this.nokiaTransform );
		//#else
			if (this.rawFrameCount == 1) {
				g.drawImage( this.image, this.xPosition, this.yPosition, Graphics.TOP | Graphics.LEFT );							
			} else { 
				// there are several frames contained in the base-image:
				int x = this.xPosition;
				int y = this.yPosition;
				//System.out.print("painting sprite at " + x + ", " + y );
				//save the current clip position:
				int clipX = g.getClipX();
				int clipY = g.getClipY();
				int clipWidth = g.getClipWidth();
				int clipHeight = g.getClipHeight();
				g.setClip( x, y, this.width, this.height );
				x -= this.column * this.width;
				y -= this.row * this.height;
			
				g.drawImage( this.image, x, y, Graphics.TOP | Graphics.LEFT );			
				
				// reset original clip:
				g.setClip( clipX, clipY, clipWidth, clipHeight );
			}
		//#endif
	}

	/**
	 * Set the frame sequence for this Sprite.
	 * 
	 * All Sprites have a default sequence that displays the Sprites
	 * frames in order.  This method allows for the creation of an
	 * arbitrary sequence using the available frames.  The current
	 * index in the frame sequence is reset to zero as a result of
	 * calling this method.
	 * <p>
	 * The contents of the sequence array are copied when this method
	 * is called; thus, any changes made to the array after this method
	 * returns have no effect on the Sprite's frame sequence.
	 * <P>
	 * Passing in <code>null</code> causes the Sprite to revert to the
	 * default frame sequence.<p>
	 * 
	 * @param sequence an array of integers, where each integer represents a frame index
	 * @throws ArrayIndexOutOfBoundsException if seq is non-null and any member of the array has a value less than 0 or greater than or equal to the number of frames as reported by getRawFrameCount()
	 * @throws IllegalArgumentException if the array has less than 1 element
	 * @see #nextFrame(), #prevFrame(), #setFrame(int), #getFrame()
	 */
	public void setFrameSequence(int[] sequence)
	{
		int[] newSequence = new int[ sequence.length ];
		System.arraycopy( sequence, 0, newSequence, 0, sequence.length );
		this.frameSequence = newSequence;
		this.frameSequenceIndex = 0;
		int frameIndex = this.frameSequence[ 0 ];
		this.column = frameIndex % this.numberOfColumns;
		this.row = frameIndex / this.numberOfColumns;
	}

	/**
	 * Changes the Image containing the Sprite's frames.
	 * <p>
	 * Replaces the current raw frames of the Sprite with a new set of raw
	 * frames.  See the constructor <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#Sprite(javax.microedition.lcdui.Image, int, int)"><CODE>Sprite(Image, int, int)</CODE></A> for
	 * information on how the frames are created from the image.  The
	 * values returned by <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getWidth()"><CODE>Layer.getWidth()</CODE></A> and <A HREF="../../../../javax/microedition/lcdui/game/Layer.html#getHeight()"><CODE>Layer.getHeight()</CODE></A>
	 * will reflect the new frame width and frame height subject to the
	 * Sprite's current transform.
	 * <p>
	 * Changing the image for the Sprite could change the number of raw
	 * frames.  If the new frame set has as many or more raw frames than the
	 * previous frame set, then:
	 * <ul>
	 * <li>The current frame will be unchanged
	 * <li>If a custom frame sequence has been defined (using
	 * <A HREF="../../../../javax/microedition/lcdui/game/Sprite.html#setFrameSequence(int[])"><CODE>setFrameSequence(int[])</CODE></A>), it will remain unchanged.  If no
	 * custom frame sequence is defined (i.e. the default frame
	 * sequence
	 * is in use), the default frame sequence will be updated to
	 * be the default frame sequence for the new frame set.  In other
	 * words, the new default frame sequence will include all of the
	 * frames from the new raw frame set, as if this new image had been
	 * used in the constructor.
	 * </ul>
	 * <p>
	 * If the new frame set has fewer frames than the previous frame set,
	 * then:
	 * <ul>
	 * <li>The current frame will be reset to entry 0
	 * <li>Any custom frame sequence will be discarded and the frame sequence
	 * will revert to the default frame sequence for the new frame
	 * set.
	 * </ul>
	 * <p>
	 * The reference point location is unchanged as a result of calling this
	 * method, both in terms of its defined location within the Sprite and its
	 * position in the painter's coordinate system.  However, if the frame
	 * size is changed and the Sprite has been transformed, the position of
	 * the Sprite's upper-left corner may change such that the reference
	 * point remains stationary.
	 * <p>
	 * If the Sprite's frame size is changed by this method, the collision
	 * rectangle is reset to its default value (i.e. it is set to the new
	 * bounds of the untransformed Sprite).
	 * <p>
	 * 
	 * @param image the Image to use for Sprite
	 * @param frameWidth the width in pixels of the individual raw frames
	 * @param frameHeight the height in pixels of the individual raw frames
	 * @throws NullPointerException if img is null
	 * @throws IllegalArgumentException if frameHeight or frameWidth is less than 1
	 *									or if the image width is not an integer multiple of the frameWidth
	 *									or if the image height is not an integer multiple of the frameHeight
	 */
	public void setImage( Image image, int frameWidth, int frameHeight)
	{
		this.image = image;
		this.frameWidth = frameWidth;
		this.width = frameWidth;
		this.frameHeight = frameHeight;
		this.height = frameHeight;
		this.numberOfColumns = image.getWidth() / frameWidth;
		int rows = image.getHeight() / frameHeight;
		this.rawFrameCount = this.numberOfColumns * rows;
		this.frameSequenceIndex = 0;
		this.column = 0;
		this.row = 0;
		this.collisionX = 0;
		this.collisionY = 0;
		this.collisionWidth = frameWidth;
		this.collisionHeight = frameHeight;
		this.transformedCollisionX = 0;
		this.transformedCollisionY = 0;
		this.transformedCollisionWidth = frameWidth;
		this.transformedCollisionHeight = frameHeight;
		//#ifdef polish.api.nokia-ui
			this.nokiaFrame = DirectUtils.createImage( frameWidth, frameHeight, 0x00FFFFFF );
			Graphics g = this.nokiaFrame.getGraphics();
			// when creating an transparent image, one must not "touch"
			// that image with an ordinary Graphics-object --- instead
			// ALWAYS an DirectGraphics-object needs to be used. Sigh!
			//g.drawImage(this.image, 0, 0, Graphics.TOP | Graphics.LEFT );
			DirectGraphics dg = DirectUtils.getDirectGraphics(g);
			dg.drawImage(this.image, 0, 0, Graphics.TOP | Graphics.LEFT, 0 );
			this.nokiaFrames = new Image[ this.rawFrameCount ];
		//#endif
	}

	/**
	 * Defines the Sprite's bounding rectangle that is used for collision
	 * detection purposes.  This rectangle is specified relative to the
	 * un-transformed Sprite's upper-left corner and defines the area that is
	 * checked for collision detection.  For pixel-level detection, only those
	 * pixels within the collision rectangle are checked.
	 * 
	 * By default, a Sprite's collision rectangle is located at 0,0 as has the
	 * same dimensions as the Sprite.  The collision rectangle may be
	 * specified to be larger or smaller than the default rectangle; if made
	 * larger, the pixels outside the bounds of the Sprite are considered to be
	 * transparent for pixel-level collision detection.
	 * 
	 * @param leftX the horizontal location of the collision rectangle relative to the untransformed Sprite's left edge
	 * @param topY the vertical location of the collision rectangle relative to the untransformed Sprite's top edge
	 * @param cWidth the width of the collision rectangle
	 * @param cHeight the height of the collision rectangle
	 * @throws IllegalArgumentException if the specified width or height is less than 0
	 */
	public void defineCollisionRectangle(int leftX, int topY, int cWidth, int cHeight)
	{
		this.collisionX = leftX;
		this.collisionY = topY;
		this.collisionWidth = cWidth;
		this.collisionHeight = cHeight;
		this.transformedCollisionX = leftX;
		this.transformedCollisionY = topY;
		this.transformedCollisionWidth = cWidth;
		this.transformedCollisionHeight = cHeight;
	}

	/**
	 * Sets the transform for this Sprite.  Transforms can be
	 * applied to a Sprite to change its rendered appearance.  Transforms
	 * are applied to the original Sprite image; they are not cumulative,
	 * nor can they be combined.  By default, a Sprite's transform is
	 * <A HREF="../../../../de/enough/polish/ui/game/Sprite.html#TRANS_NONE"><CODE>TRANS_NONE</CODE></A>.
	 * <P>
	 * Since some transforms involve rotations of 90 or 270 degrees, their
	 * use may result in the overall width and height of the Sprite
	 * being swapped.  As a result, the values returned by
	 * <A HREF="../../../../de/enough/polish/ui/game/Layer.html#getWidth()"><CODE>Layer.getWidth()</CODE></A> 
	 * and <A HREF="../../../../de/enough/polish/ui/game/Layer.html#getHeight()"><CODE>Layer.getHeight()</CODE></A> may change.
	 * <p>
	 * The collision rectangle is also modified by the transform so that
	 * it remains static relative to the pixel data of the Sprite.
	 * Similarly, the defined reference pixel is unchanged by this method,
	 * but its visual location within the Sprite may change as a result.
	 * <P>
	 * This method repositions the Sprite so that the location of
	 * the reference pixel in the painter's coordinate system does not change
	 * as a result of changing the transform.  Thus, the reference pixel
	 * effectively becomes the centerpoint for the transform.  Consequently,
	 * the values returned by <A HREF="../../../../de/enough/polish/ui/game/Sprite.html#getRefPixelX()"><CODE>getRefPixelX()</CODE></A> 
	 * and <A HREF="../../../../de/enough/polish/ui/game/Sprite.html#getRefPixelY()"><CODE>getRefPixelY()</CODE></A>
	 * will be the same both before and after the transform is applied, but
	 * the values returned by <A HREF="../../../../de/enough/polish/ui/game/Layer.html#getX()"><CODE>getX()</CODE></A> 
	 * and <A HREF="../../../../de/enough/polish/ui/game/Layer.html#getY()"><CODE>getY()</CODE></A>
	 * may change.
	 * <p>
	 * 
	 * @param transform the desired transform for this Sprite
	 * @throws IllegalArgumentException if the requested transform is invalid
	 * @see #TRANS_NONE, #TRANS_ROT90, #TRANS_ROT180, #TRANS_ROT270, #TRANS_MIRROR, #TRANS_MIRROR_ROT90, #TRANS_MIRROR_ROT180, #TRANS_MIRROR_ROT270
	 */
	public void setTransform(int transform)
	{
		boolean switchHeightAndWidth = false;
		int refX = 0;
		int refY = 0;
		switch (transform ) {
			case TRANS_NONE:
				//#debug
				System.out.println("TRANS_NONE");
				refX = this.refPixelX;
				refY = this.refPixelY;
				//#ifdef polish.api.nokia-ui
					this.nokiaTransform = 0;
				//#endif
				break;
			case TRANS_MIRROR_ROT180:
				//#debug
				System.out.println("TRANS_MIRROR_ROT180");
				refX = this.refPixelX;
				refY = (this.frameHeight - 1) - this.refPixelY;
				//#ifdef polish.api.nokia-ui
					this.nokiaTransform = DirectGraphics.FLIP_VERTICAL;
				//#endif
				break;
			case TRANS_MIRROR:
				//#debug
				System.out.println("TRANS_MIRROR");
				refX = (this.frameWidth - 1) - this.refPixelX;
				refY = this.refPixelY;
				//#ifdef polish.api.nokia-ui
					this.nokiaTransform = DirectGraphics.FLIP_HORIZONTAL;
				//#endif
				break;
			case TRANS_ROT180:
				//#debug
				System.out.println("TRANS_ROT180");
				refX = (this.frameWidth - 1) - this.refPixelX;
				refY = (this.frameHeight - 1) - this.refPixelY;
				//#ifdef polish.api.nokia-ui
					this.nokiaTransform = DirectGraphics.ROTATE_180;
				//#endif
				break;
			case TRANS_MIRROR_ROT270:
				//#debug
				System.out.println("TRANS_MIRROR_ROT270");
				refX = this.refPixelY;
				refY = this.refPixelX;
				//#ifdef polish.api.nokia-ui
					this.nokiaTransform = DirectGraphics.ROTATE_270 | DirectGraphics.FLIP_HORIZONTAL;
				//#endif
				switchHeightAndWidth = true;
				break;
			case TRANS_ROT90:
				//#debug
				System.out.println("TRANS_ROT90");
				refX = (this.frameHeight - 1) - this.refPixelY;
				refY = this.refPixelX;
				//#ifdef polish.api.nokia-ui
					this.nokiaTransform = DirectGraphics.ROTATE_270;
				//#endif
				switchHeightAndWidth = true;
				break;
			case TRANS_ROT270:
				//#debug
				System.out.println("TRANS_ROT270");
				refX = this.refPixelY; //(this.frameHeight - 1 ) - this.refPixelY;
				refY = (this.frameWidth - 1 ) - this.refPixelX;
				//#ifdef polish.api.nokia-ui
					this.nokiaTransform = DirectGraphics.ROTATE_90;
				//#endif
				switchHeightAndWidth = true;
				break;
			case TRANS_MIRROR_ROT90:
				//#debug
				System.out.println("TRANS_MIRROR_ROT90");
				refX = (this.frameHeight - 1) - this.refPixelY;
				refY = (this.frameWidth - 1) - this.refPixelX;
				//#ifdef polish.api.nokia-ui
					this.nokiaTransform = DirectGraphics.ROTATE_90 | DirectGraphics.FLIP_HORIZONTAL;
				//#endif
				switchHeightAndWidth = true;
				break;
			default:
				//#ifdef polish.debugVerbose
					throw new IllegalArgumentException("Invalid sprite transformation: " + transform );
				//#else
					//# throw new IllegalArgumentException();	
				//#endif
		}
		int xDiff = this.transformedRefX - refX;
		int yDiff = this.transformedRefY - refY;

		this.transformedRefX = refX;
		this.transformedRefY = refY;

		this.xPosition += xDiff;
		this.yPosition += yDiff;
		
		this.transformedCollisionX += xDiff;
		this.transformedCollisionY += yDiff;
		
		if (switchHeightAndWidth) {
			this.width = this.frameHeight;
			this.height = this.frameWidth;
			this.transformedCollisionWidth = this.collisionHeight;
			this.transformedCollisionHeight = this.collisionWidth;
		} else {
			this.width = this.frameWidth;
			this.height = this.frameHeight;
			this.transformedCollisionWidth = this.collisionWidth;
			this.transformedCollisionHeight = this.collisionHeight;
		}
		
		this.transform = transform;
		//#ifndef polish.api.nokia-ui
			// when the nokia-ui is used the frame-dimensions do not need to be changed:
			if (this.rawFrameCount > 1) {
				updateFrame();
			}
		//#endif
	}

	/**
	 * Checks for a collision between this Sprite and the specified Sprite.
	 * <p>
	 * The J2ME Polish implementation for MIDP/1.0 devices currently does
	 * not support a pixel-level detection. Instead only the defined
	 * collision rectangles are used. 
	 * </p>
	 * <P>
	 * If pixel-level detection is used, a collision is detected only if
	 * opaque pixels collide.  That is, an opaque pixel in the first
	 * Sprite would have to collide with an opaque  pixel in the second
	 * Sprite for a collision to be detected.  Only those pixels within
	 * the Sprites' respective collision rectangles are checked.
	 * </P>
	 * <P>
	 * If pixel-level detection is not used, this method simply
	 * checks if the Sprites' collision rectangles intersect.
	 * </P>
	 * <P>
	 * Any transforms applied to the Sprites are automatically accounted for.
	 * <P>
	 * Both Sprites must be visible in order for a collision to be
	 * detected.
	 * </P>
	 * 
	 * @param s the Sprite to test for collision with
	 * @param pixelLevel true to test for collision on a pixel-by-pixel basis, false to test using simple bounds checking.
	 * @return true if the two Sprites have collided, otherwise false
	 * @throws NullPointerException if Sprite s is null
	 */
	public final boolean collidesWith( Sprite s, boolean pixelLevel)
	{
		if (!(this.isVisible && s.isVisible)) {
			return false;
		}
		int cXStart = this.xPosition + this.transformedCollisionX;
		int cXEnd = cXStart + this.transformedCollisionWidth;
		int spriteCXStart = s.xPosition + s.transformedCollisionX;
		int spriteCXEnd = spriteCXStart + s.transformedCollisionWidth;
		if ((cXStart <= spriteCXStart && cXEnd >= spriteCXStart)
		 || (cXStart >= spriteCXEnd && cXEnd <= spriteCXEnd) ) {
			int cYStart = this.yPosition + this.transformedCollisionY;
			int cYEnd = cYStart + this.transformedCollisionHeight;
			int spriteCYStart = s.yPosition + s.transformedCollisionY;
			int spriteCYEnd = spriteCYStart + s.transformedCollisionHeight;
			if ((cYStart <= spriteCYStart && cYEnd >= spriteCYStart)
					 || (cYStart >= spriteCYEnd && cYEnd <= spriteCYEnd) ) {
				return true;
			}			
		}
		return false;
	}

	/**
	 * Checks for a collision between this Sprite and the specified TiledLayer.  
	 * 
	 * If pixel-level detection is used, a collision is
	 * detected only if opaque pixels collide.  That is, an opaque pixel in
	 * the Sprite would have to collide with an opaque pixel in TiledLayer
	 * for a collision to be detected.  Only those pixels within the Sprite's
	 * collision rectangle are checked.
	 * <P>
	 * If pixel-level detection is not used, this method simply checks if the
	 * Sprite's collision rectangle intersects with a non-empty cell in the
	 * TiledLayer.
	 * <P>
	 * Any transform applied to the Sprite is automatically accounted for.
	 * <P>
	 * The Sprite and the TiledLayer must both be visible in order for
	 * a collision to be detected.
	 * <P>
	 * 
	 * @param t - the TiledLayer to test for collision with
	 * @param pixelLevel - true to test for collision on a pixel-by-pixel basis, false to test using simple bounds checking against non-empty cells.
	 * @return true if this Sprite has collided with the TiledLayer, otherwise false
	 * @throws NullPointerException - if t is null
	 */
	public final boolean collidesWith( TiledLayer t, boolean pixelLevel)
	{
		return false;
		//TODO implement collidesWith
	}

	/**
	 * Checks for a collision between this Sprite and the specified Image
	 * with its upper left corner at the specified location.  If pixel-level
	 * detection is used, a collision is detected only if opaque pixels
	 * collide.  That is, an opaque pixel in the Sprite would have to collide
	 * with an opaque  pixel in Image for a collision to be detected.  Only
	 * those pixels within the Sprite's collision rectangle are checked.
	 * <P>
	 * If pixel-level detection is not used, this method simply checks if the
	 * Sprite's collision rectangle intersects with the Image's bounds.
	 * <P>
	 * Any transform applied to the Sprite is automatically accounted for.
	 * <P>
	 * The Sprite must be visible in order for a collision to be
	 * detected.
	 * <P>
	 * 
	 * @param image - the Image to test for collision
	 * @param leftX - the horizontal location of the Image's upper left corner
	 * @param topY - the vertical location of the Image's upper left corner
	 * @param pixelLevel - true to test for collision on a pixel-by-pixel basis, false to test using simple bounds checking
	 * @return true if this Sprite has collided with the Image, otherwise false
	 * @throws NullPointerException - if image is null
	 */
	public final boolean collidesWith( Image image, int leftX, int topY, boolean pixelLevel)
	{
		return false;
		//TODO implement collidesWith
	}

}
