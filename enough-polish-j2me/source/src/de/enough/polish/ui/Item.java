//#condition polish.usePolishGui
// generated by de.enough.doc2java.Doc2Java (www.enough.de) on Sat Dec 06 15:06:44 CET 2003
/*
 * Copyright (c) 2003, 2004 Robert Virkus / enough software
 *
 * This file is part of J2ME Polish.
 *
 * J2ME Polish is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * J2ME Polish is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Foobar; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * 
 * Commercial licenses are also available, please
 * refer to the accompanying LICENSE.txt or visit
 * www.enough.de/j2mepolish for details.
 */
package de.enough.polish.ui;

import de.enough.polish.util.ArrayList;
import de.enough.polish.util.Debug;

import javax.microedition.lcdui.*;
import javax.microedition.lcdui.Command;
import javax.microedition.lcdui.Graphics;


/**
 * A superclass for components that can be added to a Form.
 * 
 * 
 * A superclass for components that can be added to a <A HREF="../../../javax/microedition/lcdui/Form.html"><CODE>Form</CODE></A>. All <code>Item</code> objects have a label field,
 * which is a string that is
 * attached to the item. The label is typically displayed near the component
 * when it is displayed within a screen.  The label should be positioned on
 * the same horizontal row as the item or
 * directly above the item.  The implementation should attempt to distinguish
 * label strings from other textual content, possibly by displaying the label
 * in a different font, aligning it to a different margin, or appending a
 * colon to it if it is placed on the same line as other string content.
 * If the screen is scrolling, the implementation should try
 * to keep the label visible at the same time as the <code>Item</code>.
 * 
 * <p>In some cases,
 * when the user attempts to interact with an <code>Item</code>,
 * the system will switch to
 * a system-generated screen where the actual interaction takes place. If
 * this occurs, the label will generally be carried along and displayed within
 * this new screen in order to provide the user with some context for the
 * operation. For this reason it is recommended that applications supply a
 * label to all interactive Item objects. However, this is not required, and
 * a <code>null</code> value for a label is legal and specifies
 * the absence of a label.
 * </p>
 * 
 * <h3>Item Layout</h3>
 * 
 * <p>An <code>Item's</code> layout within its container is
 * influenced through layout directives:</p>
 * 
 * <ul>
 * <li> <code>LAYOUT_DEFAULT</code> </li>
 * <li> <code>LAYOUT_LEFT</code> </li>
 * <li> <code>LAYOUT_RIGHT</code> </li>
 * <li> <code>LAYOUT_CENTER</code> </li>
 * <li> <code>LAYOUT_TOP</code> </li>
 * <li> <code>LAYOUT_BOTTOM</code> </li>
 * <li> <code>LAYOUT_VCENTER</code> </li>
 * <li> <code>LAYOUT_NEWLINE_BEFORE</code> </li>
 * <li> <code>LAYOUT_NEWLINE_AFTER</code> </li>
 * <li> <code>LAYOUT_SHRINK</code> </li>
 * <li> <code>LAYOUT_VSHRINK</code> </li>
 * <li> <code>LAYOUT_EXPAND</code> </li>
 * <li> <code>LAYOUT_VEXPAND</code> </li>
 * <li> <code>LAYOUT_2</code> </li>
 * </ul>
 * 
 * <p>The <code>LAYOUT_DEFAULT</code> directive indicates
 * that the container's default
 * layout policy is to be used for this item.
 * <code>LAYOUT_DEFAULT</code> has the value
 * zero and has no effect when combined with other layout directives.  It is
 * useful within programs in order to document the programmer's intent.</p>
 * 
 * <p>The <code>LAYOUT_LEFT</code>, <code>LAYOUT_RIGHT</code>, and
 * <code>LAYOUT_CENTER</code> directives indicate
 * horizontal alignment and are mutually exclusive.  Similarly, the
 * <code>LAYOUT_TOP</code>, <code>LAYOUT_BOTTOM</code>, and
 * <code>LAYOUT_VCENTER</code> directives indicate vertical
 * alignment and are mutually exclusive.</p>
 * 
 * <p>A horizontal alignment directive, a vertical alignment directive, and
 * any combination of other layout directives may be combined using the
 * bit-wise <code>OR</code> operator (<code>|</code>) to compose a
 * layout directive value.  Such a value
 * is used as the parameter to the <A HREF="../../../javax/microedition/lcdui/Item.html#setLayout(int)"><CODE>setLayout(int)</CODE></A> method and is the return
 * value from the <A HREF="../../../javax/microedition/lcdui/Item.html#getLayout()"><CODE>getLayout()</CODE></A> method.</p>
 * 
 * <p>Some directives have no defined behavior in some contexts.  A layout
 * directive is ignored if its behavior is not defined for the particular
 * context within which the <code>Item</code> resides.</p>
 * 
 * <p>A complete specification of the layout of <code>Items</code>
 * within a <code>Form</code> is given
 * <a href="Form.html#layout">here</a>.</p>
 * 
 * <a name="sizes"></a>
 * <h3>Item Sizes</h3>
 * 
 * <p><code>Items</code> have two explicit size concepts: the <em>minimum</em>
 * size and the
 * <em>preferred</em> size.  Both the minimum and the preferred sizes refer to
 * the total area of the <code>Item</code>, which includes space for the
 * <code>Item's</code> contents,
 * the <code>Item's</code> label, as well as other space that is
 * significant to the layout
 * policy.  These sizes do not include space that is not significant for
 * layout purposes.  For example, if the addition of a label to an
 * <code>Item</code> would
 * cause other <code>Items</code> to move in order to make room,
 * then the space occupied by
 * this label is significant to layout and is counted as part of
 * the <code>Item's</code>
 * minimum and preferred sizes.  However, if an implementation were to place
 * the label in a margin area reserved exclusively for labels, this would not
 * affect the layout of neighboring <code>Items</code>.
 * In this case, the space occupied
 * by the label would not be considered part of the minimum and preferred
 * sizes.</p>
 * 
 * <p>The minimum size is the smallest size at which the
 * <code>Item</code> can function and
 * display its contents, though perhaps not optimally.  The minimum size
 * may be recomputed whenever the <code>Item's</code> contents changes.</p>
 * 
 * <p>The preferred size is generally a size based on the
 * <code>Item's</code> contents and
 * is the smallest size at which no information is clipped and text wrapping
 * (if any) is kept to a tolerable minimum.  The preferred size may be
 * recomputed whenever the <code>Item's</code> contents changes.
 * The application can
 * <em>lock</em> the preferred width or preferred height (or both) by
 * supplying specific values for parameters to the <A HREF="../../../javax/microedition/lcdui/Item.html#setPreferredSize(int, int)"><CODE>setPreferredSize</CODE></A> method.  The manner in which an
 * <code>Item</code> fits its contents
 * within an application-specified preferred size is implementation-specific.
 * However, it is recommended that textual content be word-wrapped to fit the
 * preferred size set by the application.  The application can <em>unlock</em>
 * either or both dimensions by supplying the value <code>-1</code>
 * for parameters to the <code>setPreferredSize</code> method.</p>
 * 
 * <p>When an <code>Item</code> is created, both the preferred width
 * and height are
 * unlocked.  In this state, the implementation computes the preferred width
 * and height based on the <code>Item's</code> contents, possibly
 * including other relevant
 * factors such as the <code>Item's</code> graphic design and the
 * screen dimensions.
 * After having locked either the preferred width or height, the application
 * can restore the initial, unlocked state by calling
 * <code>setPreferredSize(-1,&nbsp;-1)</code>.</p>
 * 
 * <p>The application can lock one dimension of the preferred size and leave
 * the other unlocked.  This causes the system to compute an appropriate value
 * for the unlocked dimension based on arranging the contents to fit the
 * locked dimension.  If the contents changes, the size on the unlocked
 * dimension is recomputed to reflect the new contents, but the size on the
 * locked dimension remains unchanged.  For example, if the application called
 * <code>setPreferredSize(50,&nbsp;-1)</code>, the preferred width would be
 * locked at <code>50</code> pixels and the preferred height would
 * be computed based on the
 * <code>Item's</code> contents.  Similarly, if the application called
 * <code>setPreferredSize(-1,&nbsp;60)</code>, the preferred height would be
 * locked at <code>60</code> pixels and the preferred width would be
 * computed based on the
 * <code>Item's</code> contents.  This feature is particularly useful
 * for <code>Items</code> with
 * textual content that can be line wrapped.</p>
 * 
 * <p>The application can also lock both the preferred width and height to
 * specific values.  The <code>Item's</code> contents are truncated or padded
 * as necessary to honor this request.  For <code>Items</code> containing
 * text, the text should be wrapped to the specified width, and any truncation
 * should occur at the end of the text.</p>
 * 
 * <p><code>Items</code> also have an implicit maximum size provided by the
 * implementation.  The maximum width is typically based on the width of the
 * screen space available to a <code>Form</code>.  Since <code>Forms</code>
 * can scroll vertically, the maximum height should typically not be based on
 * the height of the available screen space.</p>
 * 
 * <p>If the application attempts to lock a preferred size dimension to a
 * value smaller than the minimum or larger than the maximum, the
 * implementation may disregard the requested value and instead use either the
 * minimum or maximum as appropriate.  If this occurs, the actual values used
 * must be visible to the application via the values returned from the
 * <A HREF="../../../javax/microedition/lcdui/Item.html#getPreferredWidth()"><CODE>getPreferredWidth</CODE></A> and
 * <A HREF="../../../javax/microedition/lcdui/Item.html#getPreferredHeight()"><CODE>getPreferredHeight</CODE></A> methods.
 * </p>
 * 
 * <h3>Commands</h3>
 * 
 * <p>A <code>Command</code> is said to be present on an <code>Item</code>
 * if the <code>Command</code> has been
 * added to this <code>Item</code> with a prior call to <A HREF="../../../javax/microedition/lcdui/Item.html#addCommand(javax.microedition.lcdui.Command)"><CODE>addCommand(javax.microedition.lcdui.Command)</CODE></A>
 * or <A HREF="../../../javax/microedition/lcdui/Item.html#setDefaultCommand(javax.microedition.lcdui.Command)"><CODE>setDefaultCommand(javax.microedition.lcdui.Command)</CODE></A> and if
 * the <code>Command</code> has not been removed with a subsequent call to
 * <A HREF="../../../javax/microedition/lcdui/Item.html#removeCommand(javax.microedition.lcdui.Command)"><CODE>removeCommand(javax.microedition.lcdui.Command)</CODE></A>.  <code>Commands</code> present on an
 * item should have a command
 * type of <code>ITEM</code>.  However, it is not an error for a
 * command whose type is
 * other than <code>ITEM</code> to be added to an item.
 * For purposes of presentation and
 * placement within its user interface, the implementation is allowed to
 * treat a command's items as if they were of type <code>ITEM</code>. </p>
 * 
 * <p><code>Items</code> may have a <em>default</em> <code>Command</code>.
 * This state is
 * controlled by the <A HREF="../../../javax/microedition/lcdui/Item.html#setDefaultCommand(javax.microedition.lcdui.Command)"><CODE>setDefaultCommand(javax.microedition.lcdui.Command)</CODE></A> method.  The default
 * <code>Command</code> is eligible to be bound to a special
 * platform-dependent user
 * gesture.  The implementation chooses which gesture is the most
 * appropriate to initiate the default command on that particular
 * <code>Item</code>.
 * For example, on a device that has a dedicated selection key, pressing
 * this key might invoke the item's default command.  Or, on a
 * stylus-based device, tapping on the <code>Item</code> might
 * invoke its default
 * command.  Even if it can be invoked through a special gesture, the
 * default command should also be invokable in the same fashion as
 * other item commands.</p>
 * 
 * <p>It is possible that on some devices there is no special gesture
 * suitable for invoking the default command on an item.  In this case
 * the default command must be accessible to the user in the same
 * fashion as other item commands.  The implementation may use the state
 * of a command being the default in deciding where to place the command
 * in its user interface.</p>
 * 
 * <p>It is possible for an <code>Item</code> not to have a default command.
 * In this
 * case, the implementation may bind its special user gesture (if any)
 * for another purpose, such as for displaying a menu of commands.  The
 * default state of an <code>Item</code> is not to have a default command.
 * An <code>Item</code>
 * may be set to have no default <code>Command</code> by removing it from
 * the <code>Item</code> or
 * by passing <code>null</code> to the <code>setDefaultCommand()</code>
 * method.</p>
 * 
 * <p>The same command may occur on more than one
 * <code>Item</code> and also on more than
 * one <code>Displayable</code>.  If this situation occurs, the user
 * must be provided with
 * distinct gestures to invoke that command on each <code>Item</code> or
 * <code>Displayable</code> on
 * which it occurs, while those <code>Items</code> or <code>Displayables</code>
 * are visible on the
 * display.  When the user invokes the command, the listener
 * (<code>CommandListener</code>
 * or <code>ItemCommandListener</code> as appropriate) of just the
 * object on which the
 * command was invoked will be called.</p>
 * 
 * <p>Adding commands to an <code>Item</code> may affect its appearance, the
 * way it is laid out, and the traversal behavior.  For example, the presence
 * of commands on an <code>Item</code> may cause row breaks to occur, or it
 * may cause additional graphical elements (such as a menu icon) to appear.
 * In particular, if a <code>StringItem</code> whose appearance mode is
 * <code>PLAIN</code> (see below) is given one or more <code>Commands</code>,
 * the implementation is allowed to treat it as if it had a different
 * appearance mode.</p>
 * 
 * <a name="appearance"></a>
 * <h3>Appearance Modes</h3>
 * 
 * <p>The <code>StringItem</code> and <code>ImageItem</code> classes have an
 * <em>appearance mode</em> attribute that can be set in their constructors.
 * This attribute can have one of the values <A HREF="../../../javax/microedition/lcdui/Item.html#PLAIN"><CODE>PLAIN</CODE></A>,
 * <A HREF="../../../javax/microedition/lcdui/Item.html#HYPERLINK"><CODE>HYPERLINK</CODE></A>, or <A HREF="../../../javax/microedition/lcdui/Item.html#BUTTON"><CODE>BUTTON</CODE></A>.
 * An appearance mode of <code>PLAIN</code> is typically used
 * for non-interactive
 * display of textual or graphical material.  The appearance
 * mode values do not have any side effects on the interactivity of the item.
 * In order to be interactive, the item must have one or more
 * <code>Commands</code>
 * (preferably with a default command assigned), and it must have a
 * <code>CommandListener</code> that receives notification of
 * <code>Command</code> invocations.  The
 * appearance mode values also do not have any effect on the semantics of
 * <code>Command</code> invocation on the item.  For example,
 * setting the appearance mode
 * of a <code>StringItem</code> to be <code>HYPERLINK</code>
 * requests that the implementation display
 * the string contents as if they were a hyperlink in a browser.  It is the
 * application's responsibility to attach a <code>Command</code>
 * and a listener to the
 * <code>StringItem</code> that provide behaviors that the user
 * would expect from invoking
 * an operation on a hyperlink, such as loading the referent of the link or
 * adding the link to the user's set of bookmarks.</p>
 * 
 * <p>Setting the appearance mode of an <code>Item</code> to be other than
 * <code>PLAIN</code> may affect its minimum, preferred, and maximum sizes, as
 * well as the way it is laid out.  For example, a <code>StringItem</code>
 * with an appearance mode of <code>BUTTON</code> should not be wrapped across
 * rows.  (However, a <code>StringItem</code> with an appearance mode of
 * <code>HYPERLINK</code> should be wrapped the same way as if its appearance
 * mode is <code>PLAIN</code>.)</p>
 * 
 * <p>A <code>StringItem</code> or <code>ImageItem</code>
 * in <code>BUTTON</code> mode can be used to create a
 * button-based user interface.  This can easily lead to applications that are
 * inconvenient to use.  For example, in a traversal-based system, users must
 * navigate to a button before they can invoke any commands on it.  If buttons
 * are spread across a long <code>Form</code>, users may be required
 * to perform a
 * considerable amount of navigation in order to discover all the available
 * commands.  Furthermore, invoking a command from a button at the
 * other end of the <code>Form</code> can be quite cumbersome.
 * Traversal-based systems
 * often provide a means of invoking commands from anywhere (such as from a
 * menu), without the need to traverse to a particular item.  Instead of
 * adding a command to a button and placing that button into a
 * <code>Form</code>, it would
 * often be more appropriate and convenient for users if that command were
 * added directly to the <code>Form</code>.  Buttons should be used
 * only in cases where
 * direct user interaction with the item's string or image contents is
 * essential to the user's understanding of the commands that can be invoked
 * from that item.</p>
 * 
 * <h3>Default State</h3>
 * 
 * <p>Unless otherwise specified by a subclass, the default state of newly
 * created <code>Items</code> is as follows:</p>
 * 
 * <ul>
 * <li>the <code>Item</code> is not contained within
 * (&quot;owned by&quot;) any container;</li>
 * <li>there are no <code>Commands</code> present;</li>
 * <li>the default <code>Command</code> is <code>null</code>;</li>
 * <li>the <code>ItemCommandListener</code> is <code>null</code>;</li>
 * <li>the layout directive value is <code>LAYOUT_DEFAULT</code>; and</li>
 * <li>both the preferred width and preferred height are unlocked.</li>
 * </ul>
 * 
 * @since MIDP 1.0
 */
public abstract class Item extends Object
{
	/**
	 * A J2ME Polish constant defining a transparent/invisible color.
	 * TRANSPARENT has the value -1.
	 */
	public static final int TRANSPARENT = -1;
	
	/**
	 * A J2ME Polish constant defining a vertical orientation.
	 * VERTICAL has the value 0.
	 */
	public static final int VERTICAL = 0;
	
	/**
	 * A J2ME Polish constant defining a horizontal orientation.
	 * HORIZONTAL has the value 1.
	 */
	public static final int HORIZONTAL = 1;

	/**
	 * A layout directive indicating that this <code>Item</code>
	 * should follow the default layout policy of its container.
	 * 
	 * <P>Value <code>0</code> is assigned to <code>LAYOUT_DEFAULT</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_DEFAULT = 0;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * left-aligned layout.
	 * 
	 * <P>Value <code>1</code> is assigned to <code>LAYOUT_LEFT</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_LEFT = 1;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * right-aligned layout.
	 * 
	 * <P>Value <code>2</code> is assigned to <code>LAYOUT_RIGHT</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_RIGHT = 2;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * horizontally centered layout.
	 * 
	 * <P>Value <code>3</code> is assigned to <code>LAYOUT_CENTER</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_CENTER = 3;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * top-aligned layout.
	 * 
	 * <P>Value <code>0x10</code> is assigned to <code>LAYOUT_TOP</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_TOP = 0x10;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * bottom-aligned layout.
	 * 
	 * <P>Value <code>0x20</code> is assigned to <code>LAYOUT_BOTTOM</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_BOTTOM = 0x20;

	/**
	 * A layout directive indicating that this <code>Item</code> should have a
	 * vertically centered layout.
	 * 
	 * <P>Value <code>0x30</code> is assigned to
	 * <code>LAYOUT_VCENTER</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_VCENTER = 0x30;

	/**
	 * A layout directive indicating that this <code>Item</code>
	 * should be placed at the beginning of a new line or row.
	 * 
	 * <P>Value <code>0x100</code> is assigned to
	 * <code>LAYOUT_NEWLINE_BEFORE</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_NEWLINE_BEFORE = 0x100;

	/**
	 * A layout directive indicating that this <code>Item</code>
	 * should the last on its line or row, and that the next
	 * <code>Item</code> (if any) in the container
	 * should be placed on a new line or row.
	 * 
	 * <P>Value <code>0x200</code> is assigned to
	 * <code>LAYOUT_NEWLINE_AFTER</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_NEWLINE_AFTER = 0x200;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * width may be reduced to its minimum width.
	 * 
	 * <P>Value <code>0x400</code> is assigned to <code>LAYOUT_SHRINK</code></P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_SHRINK = 0x400;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * width may be increased to fill available space.
	 * 
	 * <P>Value <code>0x800</code> is assigned to <code>LAYOUT_EXPAND</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_EXPAND = 0x800;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * height may be reduced to its minimum height.
	 * 
	 * <P>Value <code>0x1000</code> is assigned to
	 * <code>LAYOUT_VSHRINK</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_VSHRINK = 0x1000;

	/**
	 * A layout directive indicating that this <code>Item's</code>
	 * height may be increased to fill available space.
	 * 
	 * <P>Value <code>0x2000</code> is assigned to
	 * <code>LAYOUT_VEXPAND</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_VEXPAND = 0x2000;

	/**
	 * A layout directive indicating that new MIDP 2.0 layout
	 * rules are in effect for this <code>Item</code>.  If this
	 * bit is clear, indicates that MIDP 1.0 layout behavior
	 * applies to this <code>Item</code>.
	 * 
	 * <P>Value <code>0x4000</code> is assigned to
	 * <code>LAYOUT_2</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int LAYOUT_2 = 0x4000;

	/**
	 * An appearance mode value indicating that the <code>Item</code> is to have
	 * a normal appearance.
	 * 
	 * <P>Value <code>0</code> is assigned to <code>PLAIN</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int PLAIN = 0;

	/**
	 * An appearance mode value indicating that the <code>Item</code>
	 * is to appear as a hyperlink.
	 * <P>Value <code>1</code> is assigned to <code>HYPERLINK</code>.</P>
	 * 
	 * 
	 * @since MIDP 2.0
	 */
	public static final int HYPERLINK = 1;

	/**
	 * An appearance mode value indicating that the <code>Item</code>
	 * is to appear as a button.
	 * <P>Value <code>2</code> is assigned to <code>BUTTON</code>.</P>
	 * 
	 * @since MIDP 2.0
	 */
	public static final int BUTTON = 2;

	/**
	 * A J2ME Polish appearance mode value indicating that the <code>Item</code>
	 * accepts input from the user.
	 * <P>Value <code>3</code> is assigned to <code>INTERACTIVE</code>.</P>
	 */
	public static final int INTERACTIVE = 3;
	
	protected int layout;
	protected ItemCommandListener itemCommandListener;
	protected Command defaultCommand;
	protected int preferredWidth;
	protected int preferredHeight;
	protected int minimumWidth;
	protected int minimumHeight;
	protected boolean isInitialised;
	protected Background background;
	protected Border border;
	protected Style style;
	protected String label;
	protected Font labelFont;
	protected int labelColor;
	protected int labelWidth;
	protected int labelHeight;
	protected int itemWidth;
	protected int itemHeight;
	protected int paddingLeft;
	protected int paddingTop;
	protected int paddingRight;
	protected int paddingBottom;
	protected int paddingVertical;
	protected int paddingHorizontal;
	protected int marginLeft;
	protected int marginTop;
	protected int marginRight;
	protected int marginBottom;
	/** The width of this item's content **/
	protected int contentWidth;
	/** The height of this item's content **/
	protected int contentHeight;
	protected int borderWidth;
	protected int backgroundWidth;
	protected int backgroundHeight;
	protected int appearanceMode;
	/**
	 * The screen to which this item belongs to.
	 */
	protected Screen screen;
	//#ifdef polish.useDynamicStyles
		/**
		 * The appropriate CSS selector of this item. 
		 * This is either the style's name or a selector
		 * depending on the state of this item. A StringItem
		 * can have the selector "p", "a" or "button", for example.
		 * This variable can only be used, when the proprocessing variable
		 * "polish.useDynamicStyles" is defined.
		 */
		protected String cssSelector;
	//#endif
	/**
	 * Determines whether the style has be dynamically assigned already.
	 */
	protected boolean isStyleInitialised;
	/**
	 * The parent of this item.
	 */
	protected Item parent;

	private ArrayList commands;
	
	protected boolean isLayoutCenter;
	protected boolean isLayoutExpand;
	protected boolean isLayoutRight;
	protected int xLeftPos;
	protected int yTopPos;
	protected int xRightPos;
	protected int yBottomPos;
	protected boolean isFocused;
	
	//#ifdef polish.useBeforeStyle
		private int beforeWidth;
		private int beforeHeight;
		private Image beforeImage;
	//#endif

	//#ifdef polish.useAfterStyle
		private int afterWidth;
		private int afterHeight;
		private Image afterImage;
	//#endif
	
	protected Item() {
		this( null, LAYOUT_DEFAULT, PLAIN, null );
	}
	
	protected Item( Style style ) {
		this( null, LAYOUT_DEFAULT, PLAIN, style );
	}
	
	protected Item( String label, int layout) {
		this( label, layout, PLAIN, null );
	}

	/**
	 * Creates a new Item.
	 * 
	 * @param label the label of this item
	 * @param layout the layout of this item
	 * @param appearanceMode the mode of this item, either Item.PLAIN, Item.BUTTON or Item.HYPERLINK
	 * @param style the style of this item - contains the background, border etc.
	 */
	protected Item(String label, int layout, int appearanceMode, Style style) {
		this.style = style;
		this.label = label;
		this.layout = layout;
		this.appearanceMode = appearanceMode;
		if (style == null) {
			this.layout = layout;
		} else {
			this.style = style;
			this.isStyleInitialised = false;
		}
	}

	/**
	 * Sets the label of the <code>Item</code>. If <code>label</code>
	 * is <code>null</code>, specifies that this item has no label.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within  an <code>Alert</code>.</p>
	 * 
	 * @param label - the label string
	 * @throws IllegalStateException - if this Item is contained  within an Alert
	 * @see #getLabel()
	 */
	public void setLabel( String label)
	{
		this.label = label;
	}

	/**
	 * Gets the label of this <code>Item</code> object.
	 * 
	 * @return the label string
	 * @see #setLabel(java.lang.String)
	 */
	public String getLabel()
	{
		return this.label;
	}

	/**
	 * Gets the layout directives used for placing the item.
	 * 
	 * @return a combination of layout directive values
	 * @see #setLayout(int)
	 * @since  MIDP 2.0
	 */
	public int getLayout()
	{
		return this.layout;
	}

	/**
	 * Sets the layout directives for this item.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param layout - a combination of layout directive values for this item
	 * @throws IllegalArgumentException - if the value of layout is not a bit-wise OR combination of layout directives
	 * @throws IllegalStateException - if this Item is contained within an Alert
	 * @see #getLayout()
	 * @since  MIDP 2.0
	 */
	public void setLayout(int layout)
	{
		this.layout = layout;
	}

	/**
	 * Returns the appearance mode of the <code>ImageItem</code>.
	 * See <a href="Item.html#appearance">Appearance Modes</a>.
	 * 
	 * @return the appearance mode value, one of Item.PLAIN, Item.HYPERLINK, or Item.BUTTON
	 * @since  MIDP 2.0
	 */
	public int getAppearanceMode()
	{
		return this.appearanceMode;
	}
	
	/**
	 * Sets the appearance mode of this item.
	 * 
	 * @param appearanceMode the mode value, one of Item.PLAIN, Item.HYPERLINK, or Item.BUTTON
	 */
	public void setAppearanceMode( int appearanceMode ) {
		this.appearanceMode = appearanceMode;
	}
	
	/**
	 * Retrieves the style of this item.
	 * 
	 * @return the style of this item.
	 */
	public Style getStyle() {
		return this.style;
	}
	
	/**
	 * Sets the style of this item.
	 * 
	 * @param style the new style for this item.
	 * @throws NullPointerException when style is null
	 */
	public void setStyle( Style style ) {
		this.isInitialised = false;
		this.isStyleInitialised = true;
		this.style = style;
		if (style != StyleSheet.defaultStyle) {
			this.layout = style.layout;
		}
		// horizontal styles: center -> right -> left
		if ( ( this.layout & LAYOUT_CENTER ) == LAYOUT_CENTER ) {
			this.isLayoutCenter = true;
			this.isLayoutRight = false;
		} else {
			this.isLayoutCenter = false;
			if ( ( this.layout & LAYOUT_RIGHT ) == LAYOUT_RIGHT ) {
				this.isLayoutRight = true;
			} else {
				this.isLayoutRight = false;
			}
		}
		//System.out.println(" style [" + style.name + "]: right: " + this.isLayoutRight + " center: " + this.isLayoutCenter);
		// vertical styles: vcenter -> bottom -> top
		// expanding layouts:
		if ( ( this.layout & LAYOUT_EXPAND ) == LAYOUT_EXPAND ) {
			this.isLayoutExpand = true;
		} else {
			this.isLayoutExpand = false;
		}
		this.labelFont = style.labelFont;
		this.labelColor = style.labelFontColor;
		this.background = style.background;
		this.border = style.border;
		if (this.border != null) {
			this.borderWidth = this.border.borderWidth;
		} else if (this.background != null){
			this.borderWidth = this.background.borderWidth;
		} else {
			this.borderWidth = 0;
		}
		this.paddingLeft = style.paddingLeft;
		this.paddingRight = style.paddingRight;
		this.paddingTop = style.paddingTop;
		this.paddingBottom = style.paddingBottom;
		this.paddingVertical = style.paddingVertical;
		this.paddingHorizontal = style.paddingHorizontal;
		this.marginLeft = style.marginLeft;
		this.marginRight = style.marginRight;
		this.marginTop = style.marginTop;
		this.marginBottom = style.marginBottom;
		//#ifdef polish.useBeforeStyle
		if (style.before != null) {
			this.beforeWidth = style.beforeWidth + this.paddingHorizontal;
			this.beforeHeight = style.beforeHeight;
		} else {
			this.beforeWidth = 0;
			this.beforeHeight = 0;
		}
		this.beforeImage = style.before;
		//#endif
		//#ifdef polish.useAfterStyle
		if (style.after != null) {
			this.afterWidth = style.afterWidth + this.paddingHorizontal;
			this.afterHeight = style.afterHeight;
		} else {
			this.afterWidth = 0;
			this.afterHeight = 0;
		}
		this.afterImage = style.after;
		//#endif
	}
	
	/**
	 * Retrieves the complete width of this item.
	 * Note that the width can dynamically change,
	 * e.g. when a StringItem gets a new text.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param lineWidth the maximum width of any following lines
	 * @return the complete width of this item.
	 */
	public int getItemWidth( int firstLineWidth, int lineWidth ) {
		if (!this.isInitialised) {
			init( firstLineWidth, lineWidth );
		}
		return this.itemWidth;
	}

	/**
	 * Retrieves the complete height of this item.
	 * Note that the width can dynamically change,
	 * e.g. when a new style is set.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param lineWidth the maximum width of any following lines
	 * @return the complete heigth of this item.
	 */
	public int getItemHeight( int firstLineWidth, int lineWidth ) {
		if (!this.isInitialised) {
			init( firstLineWidth, lineWidth );
		}
		return this.itemHeight;
	}

	/**
	 * Adds a context sensitive <code>Command</code> to the item.
	 * The semantic type of
	 * <code>Command</code> should be <code>ITEM</code>. The implementation
	 * will present the command
	 * only when the item is active, for example, highlighted.
	 * <p>
	 * If the added command is already in the item (tested by comparing the
	 * object references), the method has no effect. If the item is
	 * actually visible on the display, and this call affects the set of
	 * visible commands, the implementation should update the display as soon
	 * as it is feasible to do so.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param cmd the command to be added
	 * @throws IllegalStateException if this Item is contained within an Alert
	 * @throws NullPointerException if cmd is null
	 * @since  MIDP 2.0
	 */
	public void addCommand( Command cmd)
	{
		if (this.commands == null) {
			this.commands = new ArrayList();
		}
		if (!this.commands.contains( cmd )) {
			this.commands.add(cmd);
			repaint();
		}
	}

	/**
	 * Repaints the screen to which this item belongs to.
	 * Subclasses can call this method whenever their contents
	 * have changed and they need an immediate refresh. 
	 */
	protected void repaint() {
		if (this.parent instanceof Container) {
			((Container) this.parent).isInitialised = false;
		}
		Screen scr = getScreen();
		if (scr != null && scr == StyleSheet.currentScreen) {
			//#if polish.useFullScreen && polish.api.nokia-ui 
				scr.requestRepaint();
			//#else
				scr.repaint();
			//#endif
		}
	}
	
	/**
	 * Requests that this item and all its parents are to be re-initialised at the next repainting.
	 * All parents of this item are notified, too.
	 * This method should be called when an item changes its size more than
	 * usual.
	 */
	protected void requestInit() {
		this.isInitialised = false;
		Item p = this.parent;
		while ( p != null) {
			p.isInitialised = false;
			p = p.parent;
		}
	}
	
	/**
	 * Retrieves the screen to which this item belongs to.
	 * 
	 * @return either the corresponding screen or null when no screen could be found 
	 */
	protected Screen getScreen() {
		if (this.screen != null) {
			return this.screen;
		} else if (this.parent != null) {
			Item p = this.parent;
			while (p.parent != null) {
				p = p.parent;
			}
			return p.screen;
		} else {
			return null;
		}
	}

	/**
	 * Removes the context sensitive command from item. If the command is not
	 * in the <code>Item</code> (tested by comparing the object references),
	 * the method has
	 * no effect. If the <code>Item</code> is actually visible on the display,
	 * and this  call
	 * affects the set of visible commands, the implementation should update
	 * the display as soon as it is feasible to do so.
	 * 
	 * 
	 * If the command to be removed happens to be the default command,
	 * the command is removed and the default command on this Item is
	 * set to <code>null</code>.
	 * 
	 * The following code:
	 * <CODE> <pre>
	 * // Command c is the default command on Item item
	 * item.removeCommand(c);
	 * </pre> </CODE>
	 * is equivalent to the following code:
	 * <CODE> <pre>
	 * // Command c is the default command on Item item
	 * item.setDefaultCommand(null);
	 * item.removeCommand(c);
	 * </pre> </CODE>
	 * 
	 * @param cmd - the command to be removed
	 * @since  MIDP 2.0
	 */
	public void removeCommand( Command cmd)
	{
		if (this.commands != null) {
			if (cmd == this.defaultCommand) {
				this.defaultCommand = null;
			}
			if (this.commands.remove(cmd)) {
				repaint();
			}
		}
	}

	/**
	 * Sets a listener for <code>Commands</code> to this <code>Item</code>,
	 * replacing any previous
	 * <code>ItemCommandListener</code>. A <code>null</code> reference
	 * is allowed and has the effect of
	 * removing any existing listener.
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within an <code>Alert</code>.</p>
	 * 
	 * @param l - the new listener, or null.
	 * @throws IllegalStateException - if this Item is contained within an Alert
	 * @since  MIDP 2.0
	 */
	public void setItemCommandListener( ItemCommandListener l)
	{
		this.itemCommandListener = l;
	}

	/**
	 * Gets the preferred width of this <code>Item</code>.
	 * If the application has locked
	 * the width to a specific value, this method returns that value.
	 * Otherwise, the return value is computed based on the
	 * <code>Item's</code> contents,
	 * possibly with respect to the <code>Item's</code> preferred height
	 * if it is locked.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the preferred width of the Item
	 * @see #getPreferredHeight(), #setPreferredSize(int, int)
	 * @since  MIDP 2.0
	 */
	public int getPreferredWidth()
	{
		return this.preferredWidth;
	}

	/**
	 * Gets the preferred height of this <code>Item</code>.
	 * If the application has locked
	 * the height to a specific value, this method returns that value.
	 * Otherwise, the return value is computed based on the
	 * <code>Item's</code> contents,
	 * possibly with respect to the <code>Item's</code> preferred
	 * width if it is locked.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the preferred height of the Item
	 * @see #getPreferredWidth(), #setPreferredSize(int, int)
	 * @since  MIDP 2.0
	 */
	public int getPreferredHeight()
	{
		return this.preferredHeight;
	}

	/**
	 * Sets the preferred width and height for this <code>Item</code>.
	 * Values for width and height less than <code>-1</code> are illegal.
	 * If the width is between zero and the minimum width, inclusive,
	 * the minimum width is used instead.
	 * If the height is between zero and the minimum height, inclusive,
	 * the minimum height is used instead.
	 * 
	 * <p>Supplying a width or height value greater than the minimum width or
	 * height <em>locks</em> that dimension to the supplied
	 * value.  The implementation may silently enforce a maximum dimension for
	 * an <code>Item</code> based on factors such as the screen size.
	 * Supplying a value of
	 * <code>-1</code> for the width or height unlocks that dimension.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.</p>
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within  an <code>Alert</code>.</p>
	 * 
	 * @param width - the value to which the width should be locked, or -1 to unlock
	 * @param height - the value to which the height should be locked, or -1 to unlock
	 * @throws IllegalArgumentException - if width or height is less than -1
	 * @throws IllegalStateException - if this Item is contained within an Alert
	 * @see #getPreferredHeight(), #getPreferredWidth()
	 * @since  MIDP 2.0
	 */
	public void setPreferredSize(int width, int height)
	{
		this.preferredHeight = height;
		this.preferredWidth = width;
	}

	/**
	 * Gets the minimum width for this <code>Item</code>.  This is a width
	 * at which the item can function and display its contents,
	 * though perhaps not optimally.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the minimum width of the item
	 * @since  MIDP 2.0
	 */
	public int getMinimumWidth()
	{
		return this.minimumWidth;
	}

	/**
	 * Gets the minimum height for this <code>Item</code>.  This is a height
	 * at which the item can function and display its contents,
	 * though perhaps not optimally.
	 * See <a href="#sizes">Item Sizes</a> for a complete discussion.
	 * 
	 * @return the minimum height of the item
	 * @since  MIDP 2.0
	 */
	public int getMinimumHeight()
	{
		return this.minimumHeight;
	}

	/**
	 * Sets default <code>Command</code> for this <code>Item</code>.
	 * If the <code>Item</code> previously had a
	 * default <code>Command</code>, that <code>Command</code>
	 * is no longer the default, but it
	 * remains present on the <code>Item</code>.
	 * 
	 * <p>If not <code>null</code>, the <code>Command</code> object
	 * passed becomes the default <code>Command</code>
	 * for this <code>Item</code>.  If the <code>Command</code> object
	 * passed is not currently present
	 * on this <code>Item</code>, it is added as if <A HREF="../../../javax/microedition/lcdui/Item.html#addCommand(javax.microedition.lcdui.Command)"><CODE>addCommand(javax.microedition.lcdui.Command)</CODE></A>
	 * had been called
	 * before it is made the default <code>Command</code>.</p>
	 * 
	 * <p>If <code>null</code> is passed, the <code>Item</code> is set to
	 * have no default <code>Command</code>.
	 * The previous default <code>Command</code>, if any, remains present
	 * on the <code>Item</code>.
	 * </p>
	 * 
	 * <p>It is illegal to call this method if this <code>Item</code>
	 * is contained within  an <code>Alert</code>.</p>
	 * 
	 * @param cmd the command to be used as this Item's default Command, or null if there is to be no default command
	 * @throws IllegalStateException - if this Item is contained within an Alert
	 * @since  MIDP 2.0
	 */
	public void setDefaultCommand( Command cmd)
	{
		this.defaultCommand = cmd;
		if (cmd != null) {
			addCommand(cmd);
		}
	}

	/**
	 * Causes this <code>Item's</code> containing <code>Form</code> to notify
	 * the <code>Item's</code> <A HREF="../../../javax/microedition/lcdui/ItemStateListener.html"><CODE>ItemStateListener</CODE></A>.
	 * The application calls this method to inform the
	 * listener on the <code>Item</code> that the <code>Item's</code>
	 * state has been changed in
	 * response to an action.  Even though this method simply causes a call
	 * to another part of the application, this mechanism is useful for
	 * decoupling the implementation of an <code>Item</code> (in particular, the
	 * implementation of a <code>CustomItem</code>, though this also applies to
	 * subclasses of other items) from the consumer of the item.
	 * 
	 * <p>If an edit was performed by invoking a separate screen, and the
	 * editor now wishes to &quot;return&quot; to the form which contained the
	 * selected <code>Item</code>, the preferred method is
	 * <code>Display.setCurrent(Item)</code>
	 * instead of <code>Display.setCurrent(Displayable)</code>,
	 * because it allows the
	 * <code>Form</code> to restore focus to the <code>Item</code>
	 * that initially invoked the editor.</p>
	 * 
	 * <p>In order to make sure that the documented behavior of
	 * <code>ItemStateListener</code> is maintained, it is up to the caller
	 * (application) to guarantee that this function is
	 * not called unless:</p>
	 * 
	 * <ul>
	 * <li>the <code>Item's</code> value has actually been changed, and</li>
	 * <li>the change was the result of a user action (an &quot;edit&quot;)
	 * and NOT as a result of state change via calls to
	 * <code>Item's</code> APIs </li>
	 * </ul>
	 * 
	 * <p>The call to <code>ItemStateListener.itemStateChanged</code>
	 * may be delayed in order to be serialized with the event stream.
	 * The <code>notifyStateChanged</code> method does not block awaiting
	 * the completion of the <code>itemStateChanged</code> method.</p>
	 * 
	 * @throws IllegalStateException if the Item is not owned by a Form
	 * @since  MIDP 2.0
	 */
	public void notifyStateChanged()
	{
		if ( (!(this.screen instanceof Form)) || (this.screen == null)) {
			throw new IllegalStateException("notifyStateChanged() is valid only for items in Forms.");
		}
		Form form = (Form) this.screen;
		form.addToStateNotifyQueue(this);
	}
	
	/**
	 * Paints this item on the screen.
	 * This method should normally not be overriden. Override it
	 * only when you know what you are doing!
	 * 
	 * @param x the left start position of this item.
	 * @param y the top start position of this item.
	 * @param leftBorder the left border, nothing must be painted left of this position
	 * @param rightBorder the right border, nothing must be painted right of this position,
	 * 		  rightBorder > x >= leftBorder
	 * @param g the Graphics on which this item should be painted.
	 */
	public void paint( int x, int y, int leftBorder, int rightBorder, Graphics g ) {
		// initialise this item if necessary:
		if (!this.isInitialised) {
			init( rightBorder - x, rightBorder - leftBorder );
		}
		// set coordinates of this item:
		this.xLeftPos = x;
		this.yTopPos = y;
		this.xRightPos = x + this.itemWidth; //TODO rob: Item.xRightPos might differ when this item contains line breaks
		this.yBottomPos = y + this.itemHeight;
		
		leftBorder += (this.marginLeft + this.borderWidth + this.paddingLeft + this.labelWidth);
		//#ifdef polish.useBeforeStyle
			leftBorder += this.beforeWidth;
		//#endif
		//System.out.println( this.style.name + ":  increasing leftBorder by " + (this.marginLeft + this.borderWidth + this.paddingLeft));
		rightBorder -= (this.marginRight + this.borderWidth + this.paddingRight);
		//#ifdef polish.useAfterStyle
			rightBorder -= this.afterWidth;
		//#endif
		
		//System.out.println( this.style.name + ":  decreasing rightBorder by " + (this.marginRight + this.borderWidth + this.paddingRight));
		boolean doCenter = this.isLayoutCenter;
		if ( doCenter) {
			int itemSpace = rightBorder - leftBorder;
			if (itemSpace > this.itemWidth) {
				/*
				if (this.isLayoutExpand) {
					System.out.println( this.style.name + ": centering item by " + ((itemSpace - this.itemWidth) / 2)+ " pixels, event though LAYOUT_EXPAND is set!");
				}
				*/
				//System.out.println("itemSpace=" + itemSpace + "  itemWidth=" + this.itemWidth + "  x-increase=" + ((itemSpace - this.itemWidth) / 2));
				x+= (itemSpace - this.itemWidth) / 2;
				doCenter = false;
			}
		}
		boolean doRightAlign = this.isLayoutRight;
		if ( doRightAlign ) {
			int itemSpace = rightBorder - leftBorder;
			if (itemSpace > this.itemWidth) {
				/*
				if (this.isLayoutExpand) {
					System.out.println( this.style.name + ": right aligning item by " + (itemSpace - this.itemWidth)+ " pixels, event though LAYOUT_EXPAND is set!");
				}
				*/
				x+= itemSpace - this.itemWidth;
			}
		}
		// paint background:
		x += this.marginLeft;
		y += this.marginTop;
		if (this.background != null) {
			this.background.paint(x, y, this.backgroundWidth, this.backgroundHeight, g);
		}
		
		int contentX = x + this.borderWidth + this.paddingLeft;
		int contentY = y + this.borderWidth + this.paddingTop;
		int originalContentY = contentY;
		
		// paint label:
		if (this.label != null) {
			g.setFont( this.labelFont );
			g.setColor( this.labelColor );
			g.drawString(this.label, contentX, contentY, Graphics.TOP | Graphics.LEFT );
			contentX += this.labelWidth;
		}
		
		// paint before element:
		//#ifdef polish.useBeforeStyle
		if (this.beforeImage != null) {
			int beforeY = contentY;
			if ( this.beforeHeight < this.contentHeight) {
				beforeY += (this.contentHeight - this.beforeHeight) / 2;
			} else {
				contentY += (this.beforeHeight - this.contentHeight) / 2;
			}
			g.drawImage(this.beforeImage, contentX, beforeY, Graphics.TOP | Graphics.LEFT );
			contentX += this.beforeWidth;
		}
		//#endif
		
		// paint after element:
		//#ifdef polish.useAfterStyle
		if (this.afterImage != null) {
			int afterY = originalContentY;
			if ( this.afterHeight < this.contentHeight) {
				afterY += (this.contentHeight - this.afterHeight) / 2;
			} else {
				//#ifdef polish.useBeforeStyle
				if (this.afterHeight > this.beforeHeight) {
				//#endif
					contentY = originalContentY + (this.afterHeight - this.contentHeight) / 2;
				//#ifdef polish.useBeforeStyle
				}
				//#endif
			}
			g.drawImage(this.afterImage, rightBorder, afterY, Graphics.TOP | Graphics.LEFT );
		}
		//#endif
		
		// paint content:
		if ( doCenter ) {
			int contentSpace = rightBorder - this.marginRight - this.borderWidth 
					- this.paddingRight - contentX;
			if (contentSpace > this.contentWidth) {
				contentX += (contentSpace - this.contentWidth ) / 2;				
			}
		}
		if ( doRightAlign ) {
			int contentSpace = rightBorder - this.marginRight - this.borderWidth 
					- this.paddingRight - contentX;
			if (contentSpace > this.contentWidth) {
				contentX += contentSpace - this.contentWidth;				
			}
		}
		paintContent( contentX, contentY, leftBorder, rightBorder, g );
				
		// paint border:
		if (this.border != null) {
			this.border.paint(x, y, this.backgroundWidth, this.backgroundHeight, g);
		}
	}
	
	/**
	 * Initialises this item.
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param lineWidth the maximum width of any following lines
	 */
	protected final void init( int firstLineWidth, int lineWidth ) {
		//#debug
		Debug.debug("intialising item " + this.getClass().getName() );
		if (this.style != null && !this.isStyleInitialised) {
			setStyle( this.style );
		}
		//#ifdef polish.useDynamicStyles
			initStyle();
		//#endif
		if (this.label != null) {
			if (this.labelFont == null ) {
				this.labelFont = Font.getDefaultFont();
			}
			this.labelWidth = this.labelFont.stringWidth( this.label ) + this.paddingHorizontal;
			this.labelHeight = this.labelFont.getHeight();
		} else {
			this.labelWidth = 0;
			this.labelHeight = 0;
		}
		// calculate content width and content height:
		int noneContentWidth = this.labelWidth 
			 	+ this.marginLeft + this.borderWidth + this.paddingLeft 
				+ this.paddingRight + this.borderWidth + this.marginRight;
		//#ifdef polish.useBeforeStyle
		noneContentWidth += this.beforeWidth;
		//#endif
		//#ifdef polish.useAfterStyle
		noneContentWidth += this.afterWidth;
		//#endif
		int firstLineContentWidth = firstLineWidth - noneContentWidth;
		int availableContentWidth = lineWidth - noneContentWidth;
		// initialise content by subclass:
		initContent( firstLineContentWidth, availableContentWidth );
		if ( this.isLayoutExpand ) {
			this.itemWidth = lineWidth;
		} else {
			this.itemWidth = noneContentWidth + this.contentWidth;
			if (this.itemWidth > lineWidth) {
				this.itemWidth = lineWidth;
			}
		}
		int cHeight = this.contentHeight;
		//#ifdef polish.useBeforeStyle
			if (this.contentHeight < this.beforeHeight) {
				cHeight = this.beforeHeight;
			}
		//#endif
		//#ifdef polish.useAfterStyle
			if (this.contentHeight < this.afterHeight) {
				cHeight = this.afterHeight;
			}
		//#endif
		if (cHeight < this.labelHeight) {
			cHeight = this.labelHeight;
		}
		this.backgroundWidth = this.itemWidth - this.marginLeft - this.marginRight;
		this.backgroundHeight = this.borderWidth + this.paddingTop 
		 					  + cHeight 
							  + this.paddingBottom + this.borderWidth;
		this.itemHeight = this.backgroundHeight + this.marginTop + this.marginBottom;
		this.isInitialised = true;
	}
	
	//#ifdef polish.useDynamicStyles
	/**
	 * Initialises the appropriate style for this item.
	 */
	protected void initStyle() {
		//System.out.println("item [" + this.getClass().getName() + "/" + this.cssSelector + "/" + this.hashCode() + "] has been initalised: " + this.isStyleInitialised );
		if (this.isStyleInitialised) {
			return;
		}
		if (this.screen == null) {
			if (this.parent != null) {
				this.screen = this.parent.screen;
			} else {
				this.screen = StyleSheet.currentScreen;
			}
		}
		if (this.style == null) {
			this.cssSelector = createCssSelector();
			//#debug
			System.out.println("getting style for item [" + this.cssSelector + "].");
			setStyle( StyleSheet.getStyle( this ) );
		} else {
			//System.out.println("item has already style [" + this.style.name + "].");
			this.cssSelector = this.style.name;
		}
		this.isStyleInitialised = true;
	}
	//#endif
	

	/**
	 * Initialises this item. 
	 * The implementation needs to calculate and set the contentWidth and 
	 * contentHeight fields. 
	 * The implementation should take the fields preferredWidth and preferredHeight
	 * into account.
	 * 
	 * 
	 * @param firstLineWidth the maximum width of the first line 
	 * @param lineWidth the maximum width of any following lines
	 * @see #contentWidth
	 * @see #contentHeight
	 * @see #preferredWidth
	 * @see #preferredHeight
	 */
	protected abstract void initContent(int firstLineWidth, int lineWidth);
	
	/*
	 * Problem: values wie firstLineStart, lineStart und lineEnd
	 * koennen erst eingerechnet werden, wenn das Item gemalt wird,
	 * da insbesondere firstLineStart vorher nicht bekannt ist.
	 * (getItemHeight(), getItemWidth())
	 * Loesungen: 
	 *    1. jedes Item beginnt in einer neuen Zeile (wie werden dann Tabellen gemalt)
	 *    2. getHeight() getWidth() setzen isInitialised wieder zurueck
	 *       (dann wird ein Item oft unnoetigt re-initialised)
	 * 
	 * Loesung beim paint:
	 * Fallunterscheidung:
	 * item ist breiter als verfuegbarer platz:
	 * 		wenn kein Background und kein Border definiert ist:
	 * 		- firstLineStart uebergeben, Rest wie ansonsten auch 
	 *        (Berechnung der Bruchstellen, etc)
	 *      wenn Background oder Border definiert ist:
	 * 		- firstLineStart = lineStart, y = nextRowY
	 * 
	 * Allgemeines Problem: wie soll ein container seinen background
	 * malen, ohne zuvor alle items vorher in der Luft gemalt zu haben?
	 * - paint auf einem Image durchfuehren und dann (Teil) des Bildes malen 
	 *   (wie muss das bild dann dimensioniert werden - eigentlich muesste die bildschirmgr;sse ausreichen!)
	 * - wenn background definiert ist, dann nach dem ersten paint sofort
	 *   ein repaint anfordern (lustig wenn mehrere container auf einem
	 *   screen sind!)
	 * - schon bei init alle startX und startY-Werte setzen und endX/endY auswerten;
	 *   container koennte int[] xPositions und int[] yPositions fuehren,
	 *   in der alle items eingetragen werden. Problem ist dann,
	 *   wenn sich der Inhalt oder Style eines Items aendert:
	 * 		- evtl. anstelle von "this.isInitialised=false" lieber
	 *  	  Methode verwenden: void clearInitState() {
	 * 			   this.isInitialised=false;
	 * 				if (this.parent != null) {
	 * 					this.parent.clearInitState();
	 * 				}
	 *			}
	 *			Dann muessten also parent gesetzt werden, auch wenn keine dynamische styles
	 *			verwendet werden.
	 *		- wenn der focus weitergeschoben wird (und daher ein neuer
	 *		  Style gesetzt wird), dann kann container selbst isInitialised
	 *        auf false setzen. Schlauer waere es gegebenenfalls aber,
	 * 		  nur das Item neu zu berechnen und die nachfolgenden
	 * 		  x/yPositions dahingehend anzupassen - aber was ist mit 
	 * 		  Content-Aenderungen (bei jedem erfolgreichen processKey( int, int )
	 * 		  dieselbe Prozedur?)
	 * 	
	 * 
	 * Rueckgabe: gerade beim Umbruechen kann der Aufrufer die
	 * endX und endY Positionen nicht einfach errechnen, zB muss nicht die gesamte 
	 * contentHeight eingerechnet werden, wenn dahinter noch Platz fuer das naechste 
	 * Item ist.
	 * 	- paintItem setzt endX und endY:
	 * 		endY muss von Item nochmals angepasst werden (padding, margin und border)
	 * 
	 * Evtl wird's leichter wenn Items, die fuer den verbleibenden Platz
	 * zu breit sind, auf eine neue Zeile anfangen - vielleicht auch nur,
	 * wenn sie denn dann auf eine Zeile passen. Das wuerde aber gegen
	 * das gewuenschte Verhalten im JavaDoc verstossen - nur Buttons
	 * sollen nicht umgebrochen werden!
	 * 
	 * Focus: ein Item ist focusable wenn appearanceMode != PLAIN oder
	 * 	wenn es sich um ein editierbares Item handelt (ChoiceGroup, TextBox, DateField)
	 */
	
	/**
	 * Paints the content of this item.
	 * The background has already been painted and the border will be added after
	 * this method returns.
	 * 
	 * @param x the left start position
	 * @param y the upper start position
	 * @param leftBorder the left border, nothing must be painted left of this position
	 * @param rightBorder the right border, nothing must be painted right of this position
	 * @param g the Graphics on which this item should be painted.
	 */
	protected abstract void paintContent( int x, int y, int leftBorder, int rightBorder, Graphics g );
	
	//#ifdef polish.useDynamicStyles	
	/**
	 * Retrieves the CSS selector for this item.
	 * The CSS selector is used for the dynamic assignment of styles -
	 * that is the styles are assigned by the usage of the item and
	 * not by a predefined style-name.
	 * With the #style preprocessing command styles are set fix, this method
	 * yields in a faster GUI and is recommended. When in a style-sheet
	 * dynamic styles are used, e.g. "Form>p", than the selector of the
	 * item is needed.
	 * This abstract method needs only be implemented, when dynamic styles
	 * are used: #ifdef polish.useDynamicStyles
	 * 
	 * @return the appropriate CSS selector for this item.
	 */
	protected abstract String createCssSelector();	
	//#endif

	/**
	 * Handles the key-pressed event.
	 * Please note, that implementation should first try to handle the
	 * given key-code, before the game-action is processed.
	 * 
	 * @param keyCode the code of the pressed key, e.g. Canvas.KEY_NUM2
	 * @param gameAction the corresponding game-action, e.g. Canvas.UP
	 * @return
	 */
	protected boolean handleKeyPressed( int keyCode, int gameAction ) {
		return false;
	}

	/**
	 * Animates this item.
	 * Subclasses can override this method to create animations.
	 * 
	 * @return true when this item has been animated.
	 */
	public boolean animate() {
		return false;
	}

	/**
	 * Focuses this item.
	 * 
	 * @param focusedStyle the style which is used to indicate the focused state
	 * @return the current style of this item
	 */
	protected Style focus(Style focusedStyle ) {
		Style oldStyle = this.style;
		setStyle( focusedStyle );
		this.isFocused = true;
		return oldStyle;
	}
	
	/**
	 * Removes the focus from this item.
	 * 
	 * @param originalStyle the original style which will be restored.
	 */
	protected void defocus( Style originalStyle ) {
		setStyle( originalStyle );
		this.isFocused = false;
	}
	
}
